# Контрольная работа по алгоритмическим структурам сортировки и поиска на языках: C++, Python, Java (Попычко Владислав Андреевич УИБО-10-24)

## *Алгоритмы сортировки*

### 1. Анализ алгоритма сортировки выбором
**Определение:**
Сортировка выбором (Selection Sort) — алгоритм, который на каждом шаге находит минимальный элемент в неотсортированной части массива и меняет его местами с текущим элементом.

**Принцип работы:**
Программа начинается в функции `main`, где создается массив и вызывается `selectionSort()`. В методе сортировки внешний цикл проходит по всем элементам массива. Для каждой позиции внутренний цикл ищет минимальный элемент в оставшейся части. При обнаружении элемента меньше текущего минимального запоминается его позиция. После завершения поиска элементы меняются местами через временную переменную. Этот процесс повторяется для каждой позиции, постепенно формируя отсортированный массив.

**Оценка временной сложности:**
- Время: O(n²)
- Память: O(1)

**Обоснование сложности:**
Сложность O(n²) возникает из-за того, что для каждого из n элементов необходимо проверить все оставшиеся элементы в неотсортированной части, что в сумме дает n(n-1)/2 сравнений.

### 2. Анализ алгоритма сортировки обменом (пузырьком)
**Определение:**
Сортировка обменом (Bubble Sort) — алгоритм, который многократно проходит по списку, сравнивая соседние элементы и меняя их местами при неправильном порядке, до полной сортировки списка.

**Принцип работы:**
Функция `bubble_sort()` получает массив и определяет его длину. Внешний цикл контролирует количество проходов, а внутренний цикл сравнивает соседние элементы. При обнаружении неправильного порядка элементы обмениваются местами. Флаг отслеживает наличие обменов во время прохода - если обменов не было, массив уже отсортирован и цикл прерывается.

**Оценка временной сложности:**
- Время: O(n²)
- Память: O(1)

**Обоснование сложности:**
Квадратичная сложность объясняется тем, что для каждого из n элементов выполняется сравнение с соседними элементами, что в худшем случае требует n(n-1)/2 операций сравнения и обмена.

### 3. Анализ алгоритма сортировки вставками
**Определение:**
Сортировка вставками (Insertion Sort) — алгоритм, который строит отсортированную часть списка, постепенно вставляя каждый новый элемент на правильную позицию среди уже отсортированных элементов.

**Принцип работы:**
Функция `insertionSort()` обрабатывает массив, начиная со второго элемента. Для каждого текущего элемента сохраняется его значение, затем все большие элементы сдвигаются вправо, освобождая место для вставки текущего элемента на правильную позицию. Этот процесс повторяется для всех элементов массива.

**Оценка временной сложности:**
- Время: O(n²)
- Память: O(1)

**Обоснование сложности:**
В худшем случае каждый новый элемент требует сравнения и сдвига всех предыдущих элементов, что приводит к n(n-1)/2 операциям сравнения и обмена.

### 4. Анализ алгоритма сортировки слиянием
**Определение:**
Сортировка слиянием (Merge Sort) — алгоритм, основанный на принципе "разделяй и властвуй": массив разделяется пополам, каждая половина сортируется рекурсивно, затем отсортированные половины сливаются в один массив.

**Принцип работы:**
Метод `mergeSort` проверяет, содержит ли часть массива более одного элемента. Если да, вычисляется середина и рекурсивно вызывается сортировка для левой и правой половин. Затем вызывается метод `merge`, который создает временные массивы для обеих половин, сравнивает их элементы и сливает обратно в исходный массив в отсортированном порядке.

**Оценка временной сложности:**
- Время: O(n log n)
- Память: O(n)

**Обоснование сложности:**
Массив делится пополам log n раз, и на каждом уровне рекурсии выполняется операция слияния всех n элементов, что в сумме дает n операций на log n уровней.

### 5. Анализ алгоритма сортировки Шелла
**Определение:**
Сортировка Шелла (Shell Sort) — модификация сортировки вставками, которая сортирует элементы, находящиеся на определенном расстоянии друг от друга, постепенно уменьшая это расстояние.

**Принцип работы:**
Функция начинается с большого шага, который постепенно уменьшается. Для каждого шага обрабатываются элементы, находящиеся на этом расстоянии. Элементы сравниваются и при необходимости перемещаются, подобно сортировке вставками, но с заданным шагом.

**Оценка временной сложности:**
- Время: O(n²)
- Память: O(1)

**Обоснование сложности:**
При неудачной последовательности шагов в худшем случае может потребоваться квадратичное число операций, особенно когда массив отсортирован в обратном порядке.

### 6. Анализ алгоритма быстрой сортировки
**Определение:**
Быстрая сортировка (Quick Sort) — эффективный алгоритм, использующий стратегию "разделяй и властвуй": выбирается опорный элемент, массив разделяется на элементы меньше и больше опорного, затем процесс повторяется рекурсивно для обеих частей.

**Принцип работы:**
Функция выбирает опорный элемент, затем переупорядочивает массив так, чтобы все элементы меньше опорного оказались слева, а большие - справа. Затем рекурсивно применяет тот же процесс к левой и правой частям массива.

**Оценка временной сложности:**
- Время: O(n log n)
- Память: O(log n)

**Обоснование сложности:**
В среднем случае массив делится на примерно равные части на каждом уровне рекурсии, создавая log n уровней, где на каждом уровне выполняется операция разделения с O(n) операциями.

### 7. Анализ алгоритма пирамидальной сортировки
**Определение:**
Пирамидальная сортировка (Heap Sort) — алгоритм, который строит из массива специальную структуру данных "кучу", затем постепенно извлекает наибольший элемент из кучи и помещает его в конец списка.

**Принцип работы:**
Метод сначала строит max-кучу из массива, затем начинает извлекать элементы: корень (максимальный элемент) перемещается в конец массива, после чего свойства кучи восстанавливаются для оставшихся элементов. Процесс повторяется до полной сортировки массива.

**Оценка временной сложности:**
- Время: O(n log n)
- Память: O(1)

**Обоснование сложности:**
Построение кучи занимает O(n) времени, а каждое из n извлечений максимального элемента требует O(log n) времени для перестройки кучи, что в сумме дает O(n log n) операций.

## *Алгоритмы поиска*

### 8. Анализ алгоритма линейного поиска
**Определение:**
Линейный поиск (Linear Search) — простейший алгоритм поиска, который последовательно проверяет каждый элемент множества до тех пор, пока не найдет искомый элемент или не достигнет конца множества.

**Принцип работы:**
Функция последовательно перебирает элементы массива в цикле. На каждой итерации проверяется соответствие текущего элемента целевому значению. При нахождении совпадения возвращается индекс элемента, в противном случае возвращается -1.

**Оценка временной сложности:**
- Время: O(n)
- Память: O(1)

**Обоснование сложности:**
В худшем случае алгоритму требуется проверить все n элементов массива, при этом количество операций растет линейно с увеличением размера массива.

### 9. Анализ алгоритма бинарного поиска
**Определение:**
Бинарный поиск (Binary Search) — эффективный алгоритм поиска в отсортированном массиве, который repeatedly делит область поиска пополам, сравнивая средний элемент с искомым значением.

**Принцип работы:**
Алгоритм использует два указателя, обозначающих текущий диапазон поиска. На каждом шаге вычисляется средний элемент диапазона. Если средний элемент равен целевому, поиск завершается. Если целевой элемент больше среднего, поиск продолжается в правой половине, если меньше - в левой.

**Оценка временной сложности:**
- Время: O(log n)
- Память: O(1)

**Обоснование сложности:**
На каждом шаге область поиска уменьшается вдвое, что означает, что даже для массива из миллиона элементов потребуется не более 20 сравнений.

### 10. Анализ алгоритма интерполяционного поиска
**Определение:**
Интерполяционный поиск (Interpolation Search) — улучшенный алгоритм поиска в отсортированных массивах с равномерным распределением данных, который предсказывает позицию искомого элемента на основе значений границ диапазона.

**Принцип работы:**
Алгоритм использует интерполяционную формулу для предсказания позиции искомого элемента. В отличие от бинарного поиска, который всегда делит диапазон пополам, интерполяционный поиск пытается сразу перейти к предполагаемой позиции элемента.

**Оценка временной сложности:**
- Время: O(log log n)
- Память: O(1)

**Обоснование сложности:**
При равномерном распределении данных алгоритм экспоненциально уменьшает область поиска на каждом шаге, находя элемент за двойной логарифм от количества элементов.

### 11. Анализ алгоритма поиска по Фибоначчи
**Определение:**
Поиск по Фибоначчи (Fibonacci Search) — алгоритм поиска, использующий числа Фибоначчи для определения позиций сравнения в отсортированном массиве.

**Принцип работы:**
Алгоритм генерирует последовательность Фибоначчи и использует ее для определения позиций сравнения. Похож на бинарный поиск, но использует деление массива в пропорциях, соответствующих числам Фибоначчи.

**Оценка временной сложности:**
- Время: O(log n)
- Память: O(1)

**Обоснование сложности:**
Алгоритм делит массив с помощью чисел Фибоначчи, которые растут экспоненциально, что гарантирует логарифмическое количество сравнений относительно размера массива.
